<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端知识</title>
      <link href="/2023/08/28/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/08/28/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>面试一些常见的问题</p><span id="more"></span><h1 id="1-浏览器渲染原理"><a class="markdownIt-Anchor" href="#1-浏览器渲染原理">#</a> 1、浏览器渲染原理</h1><ul><li>构建 DOM 树</li></ul><p>主要是将 html 内容转换为浏览器 DOM 树结构</p><ul><li><p>样式计算</p></li><li><p>格式化样式表</p></li><li><p>标准化样式表</p></li><li><p>计算每个 DOM 节点具体样式</p></li><li><p>布局阶段</p></li></ul><p>（1）生成布局树</p><p>（2）创建布局树</p><p>（3）布局计算</p><p>浏览器根据 Layout Tree 所体现的节点、各个节点的 CSS 定义以及它们的从属关系，计算出每个节点在屏幕中的位置</p><ul><li><p>分层</p></li><li><p>绘制</p></li><li><p>分块</p></li><li><p>栅格化</p></li><li><p>合成</p></li><li><p>关于回流、重绘、合成</p></li></ul><p>Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为<strong>回流</strong>。</p><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility 等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为<strong>重绘</strong>。</p><p><strong>更改了一个既不要布局也不要绘制</strong>的属性，那么渲染引擎会跳过布局和绘制，直接执行后续的<strong>合成</strong>操作，这个过程就叫<strong>合成</strong>。</p><h1 id="2-函数式与面向对象编程思想"><a class="markdownIt-Anchor" href="#2-函数式与面向对象编程思想">#</a> 2、函数式与面向对象编程思想</h1><h2 id="21-函数式编程"><a class="markdownIt-Anchor" href="#21-函数式编程">#</a> 2.1、函数式编程</h2><h3 id="211-概念"><a class="markdownIt-Anchor" href="#211-概念">#</a> 2.1.1、概念</h3><p>函数式编程（Functional Programming）是一种编程范式，它强调将计算过程看作是函数之间的转换而不是状态的改变。它将函数视为一等公民，即函数可以像变量一样传递和使用，因此，函数可以作为参数传递给其他函数或作为返回值返回。</p><h3 id="212-特点"><a class="markdownIt-Anchor" href="#212-特点">#</a> 2.1.2、特点</h3><ol><li>函数是一等公民：函数可以作为参数传递给其他函数或作为返回值返回。</li><li>纯函数：函数的输出仅由输入决定，不会对外部状态产生影响。</li><li>没有副作用：函数不会修改程序状态或全局变量，只会返回新的值。</li><li>高阶函数：函数可以接受其他函数作为参数，也可以返回一个函数。</li></ol><h3 id="213-注意"><a class="markdownIt-Anchor" href="#213-注意">#</a> 2.1.3、注意</h3><p>将函数作为参数传递是函数式编程的一个特征，但它并不意味着该语言就是函数式编程语言。函数式编程是一种编程范式，它关注的是如何设计代码、如何组织数据、如何进行计算等方面，而不仅仅是一种语言的特性。</p><p>案例：求出一组数中大于 10 的数的和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums a collection of numbers </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> a collection of numbers greater than 10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filter_num</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="title function_">filter</span>(<span class="function"><span class="params">ele</span> =&gt;</span> ele &gt; <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; nums  a collection of numbers</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span>  sum of numbers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum_nums</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, curr</span>) =&gt;</span> sum + curr, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">50</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum_nums</span>(<span class="title function_">filter_num</span>(nums)));</span><br></pre></td></tr></table></figure><h2 id="22-面向过程编程"><a class="markdownIt-Anchor" href="#22-面向过程编程">#</a> 2.2、面向过程编程</h2><h3 id="221-概念"><a class="markdownIt-Anchor" href="#221-概念">#</a> 2.2.1、概念</h3><p>面向过程编程 (POP)：(Process-oriented programming) 是一种以过程为中心的编程思想，分析出解决问题的所需要的步骤，然后用函数把这些步骤一步一步实现，然后依次调用；</p><h2 id="23-面向对象编程"><a class="markdownIt-Anchor" href="#23-面向对象编程">#</a> 2.3、面向对象编程</h2><h3 id="231-概念"><a class="markdownIt-Anchor" href="#231-概念">#</a> 2.3.1、概念</h3><p>面向对象编程 (OOP)：(Object-oriented Programing) 编程过程中把所涉及到的事物分解成一个个对象，然后由对象之间加工合作，就是 (对象和方法)</p><h3 id="232-特性"><a class="markdownIt-Anchor" href="#232-特性">#</a> 2.3.2、特性</h3><ul><li><p>封装：一个对象所封装的有自己的属性和方法，有点，降低耦合性，可重复调用某个类中的属性和方法</p></li><li><p>继承：继承是子对象可以继承父对象的属性和行为</p></li><li><ul><li>实现继承: ES 语法只支持实现继承，主要依靠原型链实现的 (参考下边)</li><li>接口继承：接口继承 js 中暂时无法实现</li></ul></li><li><p>多态：通俗的讲就是同一个函数，因为传递的参数不同，可以实现的功能也不同</p></li></ul><p><strong>面向对象的继承</strong><br> 1、原型链继承</p><p><strong>注意:</strong> 当原型链中包含引用类型值的原型时，该引用值会被所有实例共享，创建子类型 (创建 Son 实例), 不能向父类 (Father) 的构造函数中传递参数；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建父构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = [<span class="string">&#x27;小米&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建子构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承Father</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例子对象</span></span><br><span class="line"><span class="keyword">let</span> son1 = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son1.<span class="property">name</span>);</span><br><span class="line"><span class="comment">// 更改子对象name</span></span><br><span class="line">son1.<span class="property">name</span>[<span class="number">0</span>] = <span class="string">&#x27;小红&#x27;</span></span><br><span class="line"><span class="comment">//实例第二个子对象</span></span><br><span class="line"><span class="keyword">let</span> son2 = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son1.<span class="property">name</span>, son2.<span class="property">name</span>); <span class="comment">//可以看到子对象修改，父对象也会修改，注意：只有引用类型才会出现此现象</span></span><br></pre></td></tr></table></figure><p>2、</p><p>案例：求出一组数中大于 10 的数的和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面向对象 oop</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumFilter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">nums</span> = nums</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">filter_num</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">nums</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">ele</span> =&gt;</span> ele &gt; <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sum_num</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, curr</span>) =&gt;</span> sum + curr, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">50</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> sum_filter = <span class="keyword">new</span> <span class="title class_">SumFilter</span>(nums)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum_filter.<span class="title function_">sum_num</span>(sum_filter.<span class="title function_">filter_num</span>()));</span><br></pre></td></tr></table></figure><h1 id="3-js如何处理异步任务"><a class="markdownIt-Anchor" href="#3-js如何处理异步任务">#</a> 3、js 如何处理异步任务</h1><h2 id="31-promise"><a class="markdownIt-Anchor" href="#31-promise">#</a> 3.1、promise</h2><p>原理：状态管理机，可以将异步任务的状态从未完成（pending）变为完成（fulfilled）和失败（rejected）</p><h2 id="32-async-await"><a class="markdownIt-Anchor" href="#32-async-await">#</a> 3.2、async await</h2><h2 id="33-generator"><a class="markdownIt-Anchor" href="#33-generator">#</a> 3.3、generator</h2><p>关键字 function*      yield</p><h2 id="34-callback"><a class="markdownIt-Anchor" href="#34-callback">#</a> 3.4、callback</h2><h2 id="35-发布订阅"><a class="markdownIt-Anchor" href="#35-发布订阅">#</a> 3.5、发布订阅</h2><h1 id="4-vue特殊传参"><a class="markdownIt-Anchor" href="#4-vue特殊传参">#</a> 4、vue 特殊传参</h1><p>$attrs 可以接收没有在 props 中声明的父组件传递的值</p><p>$slots 可以查看父组件所有插槽信息</p><h1 id="5-vue权限控制"><a class="markdownIt-Anchor" href="#5-vue权限控制">#</a> 5、vue 权限控制</h1><p>（1）登录权限</p><p>（2）页面权限</p><p>（3）功能权限</p><h1 id="6-浏览器常见兼容性问题"><a class="markdownIt-Anchor" href="#6-浏览器常见兼容性问题">#</a> 6、浏览器常见兼容性问题</h1><ul><li>使用 Trident 内核的浏览器：IE、Maxthon、TT；</li><li>使用 Gecko 内核的浏览器：Netcape6 及以上版本、FireFox；</li><li>使用 Presto 内核的浏览器：Opera7 及以上版本；</li><li>使用 Webkit 内核的浏览器：Safari、Chrome</li></ul><p>常说的兼容性问题，主要是说 IE 与几个主流浏览器如 firefox，google 等。而对 IE 浏览器来说，IE7 又是个跨度，因为之前的版本更新甚慢，bug 甚多。从 IE8 开始，IE 浏览器渐渐遵循标准，到 IE9 后由于大家都一致认为标准很重要，可以说在兼容性上比较好了，但是在中国来说，由于 xp 的占有率问题，使用 IE7 以下的用户仍然很多，所以我们不得不考虑低版本浏览器的兼容。</p><p>对浏览器兼容问题，一般分，HTML，Javascript 兼容，CSS 兼容。 其中 html 相关问题比较容易处理，无非是高版本浏览器用了低版本浏览器无法识别的元素，导致其不能解析，所以平时注意一点就是。特别新的结束出现带来高更好开发效率，但是老版本的适应性格就会出现问题.</p><p>问题一：不同浏览器的标签默认的外补丁和内补丁不同</p><p>问题症状：随便写几个标签，不加样式控制的情况下，各自的 margin 和 padding 差异较大。</p><p>碰到频率：100%</p><p margin:0;padding:0;="">解决方案：css 里 *</p><p>备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的 css 文件开头都会用通配符 * 来设置各个标签的内外补丁是 0。</p><p>问题二：块属性标签 float 后，又有横行的 margin 情况下，在 ie6 显示 margin 比设置的大</p><p>问题症状：常见症状是 ie6 中后面的一块被顶到下一行</p><p>碰到频率：90%（稍微复杂点的页面都会碰到，float 布局最常见的浏览器兼容问题）</p><p>解决方案：在 float 的标签样式控制中加入 display:inline; 将其转化为行内属性</p><p>备注：我们最常用的就是 div+css 布局了，而 div 就是一个典型的块属性标签，横向布局的时候我们通常都是用 div float 实现的，横向的间距设置如果用 margin 实现，这就是一个必然会碰到的兼容性问题。</p><p>问题三：设置较小高度标签（一般小于 10px），在 ie6，ie7，遨游中高度超出自己设置高度</p><p>问题症状：ie6、7 和遨游里这个标签的高度不受控制，超出自己设置的高度</p><p>碰到频率：60%</p><p>解决方案：给超出高度的标签设置 overflow:hidden; 或者设置行高 line-height 小于你设置的高度。</p><p>备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是 ie8 之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。</p><p>7、css 样式穿透</p><p>css 中   /deep/</p><p>vue 中  ::v-deep</p><p>8、keep-alive</p><p><code>KeepAlive</code>  组件接受三个 <code>Props</code>  属性：</p><ul><li><code>include</code>  -  <code>string | RegExp | Array</code> 。只有名称匹配的组件会被缓存。</li><li><code>exclude</code>  -  <code>string | RegExp | Array</code> 。任何名称匹配的组件都不会被缓存。</li><li><code>max</code>  -  <code>number | string</code> 。最多可以缓存多少组件实例。</li></ul><p>vue3 可以在 setup 函数中，通过 slots.default () 获取 keep-alive 包裹的组件</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一下小程序开发中的问题</title>
      <link href="/2023/08/22/%E8%AE%B0%E4%B8%80%E4%B8%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/22/%E8%AE%B0%E4%B8%80%E4%B8%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题">#</a> 1、问题</h3><p>1、在遇到接口不同一时，常用或运算来实现数据显示</p><p>2、子传父使用 this.triggerEvent 方法</p><p>3、子组件可以使用 observe 监听父组件来实现在组件内部使用父组件数据</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序开发</title>
      <link href="/2023/08/19/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
      <url>/2023/08/19/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="小程序知识总结"><a class="markdownIt-Anchor" href="#小程序知识总结">#</a> 小程序知识总结</h1><h2 id="1-小程序开发流程"><a class="markdownIt-Anchor" href="#1-小程序开发流程">#</a> 1、小程序开发流程</h2><ol><li>首先在微信公众平台注册小程序账号，获取 appID</li><li>填写小程序基本信息，并下载微信开发者工具</li><li>使用小程序 appID 创建小程序项目，并编写完善项目</li><li>上传小程序项目为测试版，由测试人员测试并修改 BUG</li><li>测试完成后，在微信公众平台提交发布，人工审核通过即可</li></ol><h2 id="2-小程序的优劣势"><a class="markdownIt-Anchor" href="#2-小程序的优劣势">#</a> 2、小程序的优劣势</h2><h3 id="1优势"><a class="markdownIt-Anchor" href="#1优势">#</a> （1）优势</h3><ul><li>容易上手，基础组件库比较全，基本上不需要考虑兼容问题；</li><li>即用即走，不用安装，省流量，省安装时间，不占用桌面</li><li>依托微信流量，天生推广传播优势</li><li>开发成本比 App 低</li></ul><h3 id="2缺点"><a class="markdownIt-Anchor" href="#2缺点">#</a> （2）缺点</h3><ul><li>样式单一，部分组件已经是成型了的，样式不可修改，例如：幻灯片、导航入口</li><li>相对传统 App 要深很多</li><li>限制较多，页面大小不能超过 2M。不能打开超过 5 个层级的页面</li></ul><h2 id="3-小程序的生命周期"><a class="markdownIt-Anchor" href="#3-小程序的生命周期">#</a> 3、小程序的生命周期</h2><h3 id="1应用生命周期"><a class="markdownIt-Anchor" href="#1应用生命周期">#</a> （1）应用生命周期</h3><ul><li>onLauch：应用初始化完成触发，全局只触发一次</li><li>onShow：应用启动，或从后台进入前台触发</li><li>onHide：应用从前台进入后台触发</li><li>onError：应用报错时触发</li></ul><h3 id="2页面生命周期"><a class="markdownIt-Anchor" href="#2页面生命周期">#</a> （2）页面生命周期</h3><ul><li>onLoad：页面加载时触发，只会调用一次，一般用来发送数据请求，可获取当前页面路径中的参数。</li><li>onReady：页面初次染完成时触发，只会调用一次，代表页面已可和视图层进行交互。获取节点信息</li><li>onShow：页面显示 / 切入前台时触发</li><li>onHide：页面隐藏 / 切入后台时触发，如底部 tab 切换到其他页面或小程序切入后台触发</li><li>onUnload：页面卸载时触发，如 redirectTo 或 navigateBack 到其他页面时</li><li>onPullDownRefresh：页面下拉刷新时执行</li><li>onReachBottom：页面触底时执行</li><li>onShareAppMessage：页面被用户分享时执行</li></ul><h2 id="4-页面路由"><a class="markdownIt-Anchor" href="#4-页面路由">#</a> 4、页面路由</h2><h3 id="1页面栈"><a class="markdownIt-Anchor" href="#1页面栈">#</a> （1）页面栈</h3><table><thead><tr><th style="text-align:left">路由方式</th><th style="text-align:left">页面栈表现</th></tr></thead><tbody><tr><td style="text-align:left">初始化</td><td style="text-align:left">新页面入栈</td></tr><tr><td style="text-align:left">打开新页面</td><td style="text-align:left">新页面入栈</td></tr><tr><td style="text-align:left">页面重定向</td><td style="text-align:left">当前页面出栈，新页面入栈</td></tr><tr><td style="text-align:left">页面返回</td><td style="text-align:left">页面不断出栈，直到目标返回页</td></tr><tr><td style="text-align:left">Tab 切换</td><td style="text-align:left">页面全部出栈，只留下新的 Tab 页面</td></tr><tr><td style="text-align:left">重加载</td><td style="text-align:left">页面全部出栈，只留下新的页面</td></tr></tbody></table><h3 id="2路由方式"><a class="markdownIt-Anchor" href="#2路由方式">#</a> （2）路由方式</h3><table><thead><tr><th style="text-align:left">路由方式</th><th style="text-align:left">触发时机</th><th style="text-align:left">路由前页面</th><th style="text-align:left">路由后页面</th></tr></thead><tbody><tr><td style="text-align:left">初始化</td><td style="text-align:left">小程序打开的第一个页面</td><td style="text-align:left"></td><td style="text-align:left">onLoad, onShow</td></tr><tr><td style="text-align:left">打开新页面</td><td style="text-align:left">调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html">wx.navigateTo</a> 使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html"> <code>navigator</code> </a></td><td style="text-align:left">onHide</td><td style="text-align:left">onLoad, onShow</td></tr><tr><td style="text-align:left">页面重定向</td><td style="text-align:left">调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.redirectTo.html">wx.redirectTo</a> 使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html"> <code>navigator</code> </a></td><td style="text-align:left">onUnload</td><td style="text-align:left">onLoad, onShow</td></tr><tr><td style="text-align:left">页面返回</td><td style="text-align:left">调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html">wx.navigateBack</a> 使用组件<a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html"> <code>navigator</code> </a> 用户按左上角返回按钮</td><td style="text-align:left">onUnload</td><td style="text-align:left">onShow</td></tr><tr><td style="text-align:left">Tab 切换</td><td style="text-align:left">调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html">wx.switchTab</a> 使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html"> <code>navigator</code> </a> 用户切换 Tab</td><td style="text-align:left"></td><td style="text-align:left">各种情况请参考下表</td></tr><tr><td style="text-align:left">重启动</td><td style="text-align:left">调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.reLaunch.html">wx.reLaunch</a> 使用组件 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html"> <code>navigator</code> </a></td><td style="text-align:left">onUnload</td><td style="text-align:left">onLoad, onShow</td></tr></tbody></table><p>Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）：</p><table><thead><tr><th style="text-align:left">当前页面</th><th style="text-align:left">路由后页面</th><th style="text-align:left">触发的生命周期（按顺序）</th></tr></thead><tbody><tr><td style="text-align:left">A</td><td style="text-align:left">A</td><td style="text-align:left">Nothing happend</td></tr><tr><td style="text-align:left">A</td><td style="text-align:left">B</td><td style="text-align:left">A.onHide(), B.onLoad(), B.onShow()</td></tr><tr><td style="text-align:left">A</td><td style="text-align:left">B（再次打开）</td><td style="text-align:left">A.onHide(), B.onShow()</td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">A</td><td style="text-align:left">C.onUnload(), A.onShow()</td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">B</td><td style="text-align:left">C.onUnload(), B.onLoad(), B.onShow()</td></tr><tr><td style="text-align:left">D</td><td style="text-align:left">B</td><td style="text-align:left">D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()</td></tr><tr><td style="text-align:left">D（从转发进入）</td><td style="text-align:left">A</td><td style="text-align:left">D.onUnload(), A.onLoad(), A.onShow()</td></tr><tr><td style="text-align:left">D（从转发进入）</td><td style="text-align:left">B</td><td style="text-align:left">D.onUnload(), B.onLoad(), B.onShow()</td></tr></tbody></table><h4 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项">#</a> 注意事项</h4><ul><li><code>navigateTo</code> ,  <code>redirectTo</code>  只能打开非 tabBar 页面。</li><li><code>switchTab</code>  只能打开 tabBar 页面。</li><li><code>reLaunch</code>  可以打开任意页面。</li><li>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。</li><li>调用页面路由带的参数可以在目标页面的 <code>onLoad</code>  中获取。</li></ul><h2 id="5-导航"><a class="markdownIt-Anchor" href="#5-导航">#</a> 5、导航</h2><h3 id="1编程式导航"><a class="markdownIt-Anchor" href="#1编程式导航">#</a> （1）编程式导航</h3><ul><li><p>1、wx.switchTab(Object object)</p><p>功能描述:</p><p>跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">switchTab</span>(&#123;</span><br><span class="line">   <span class="attr">url</span>: <span class="string">&#x27;url&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>2、wx.reLaunch(Object object)</p><p>功能描述：</p><p>关闭所有页面，打开到应用内的某个页面，可以跳转到任何一个页面，对比 navigateTo (), 保留当前页面再跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">reLaunch</span>(&#123;</span><br><span class="line">   <span class="attr">url</span>: <span class="string">&#x27;url&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>3、wx.redirectTo(Object object)</p><p>功能描述</p><p>关闭当前页面，跳转到应用内的某个页面，但是不允许跳转到 tabbar 页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">redirectTo</span>(&#123;</span><br><span class="line">   <span class="attr">url</span>: <span class="string">&#x27;url&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>4、wx.navigateTo(Object object)</p><p>功能描述：</p><p>保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html">wx.navigateBack</a> 可以返回到原页面。</p><p>对于页面不是很多的小程序，通常推荐使用 wx.navigateTo 进行跳转，以便返回页面，以提高加载速度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;url&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>5、wx.navigateBack(Object object)</p><p>功能描述</p><p>关闭当前页面，返回上一页面或多级页面。可通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/getCurrentPages.html">getCurrentPages</a> 获取当前的页面栈，决定需要返回几层</p><p>小程序的页面栈最多 10 层</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">navigateBack</span>()</span><br></pre></td></tr></table></figure></li><li><p>6、跳转到其他小程序，需要配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">navigateBackMiniProgram</span>(&#123;</span><br><span class="line">      <span class="attr">appId</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">extraData</span>: &#123;</span><br><span class="line">        <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">envVersion</span>: <span class="string">&#x27;develop&#x27;</span>,</span><br><span class="line">      <span class="title function_">success</span>(<span class="params">res</span>) &#123;</span><br><span class="line"><span class="comment">//打开成功</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2声明式导航"><a class="markdownIt-Anchor" href="#2声明式导航">#</a> （2）声明式导航</h3><table><thead><tr><th style="text-align:left">open-type 合法值</th><th style="text-align:left">说明</th><th style="text-align:left">最低版本</th></tr></thead><tbody><tr><td style="text-align:left">navigate</td><td style="text-align:left">对应 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html">wx.navigateTo</a> 或 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.navigateToMiniProgram.html">wx.navigateToMiniProgram</a> 的功能</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">redirect</td><td style="text-align:left">对应 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.redirectTo.html">wx.redirectTo</a> 的功能</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">switchTab</td><td style="text-align:left">对应 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html">wx.switchTab</a> 的功能</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">reLaunch</td><td style="text-align:left">对应 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.reLaunch.html">wx.reLaunch</a> 的功能</td><td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.1.0</a></td></tr><tr><td style="text-align:left">navigateBack</td><td style="text-align:left">对应 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html">wx.navigateBack</a> 或 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.navigateBackMiniProgram.html">wx.navigateBackMiniProgram</a> （基础库 2.24.4 版本支持）的功能</td><td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.1.0</a></td></tr><tr><td style="text-align:left">exit</td><td style="text-align:left">退出小程序， <code>target=&quot;miniProgram&quot;</code>  时生效</td><td style="text-align:left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.1.0</a></td></tr></tbody></table><h2 id="6-bindtap和catchtap的区别是什么"><a class="markdownIt-Anchor" href="#6-bindtap和catchtap的区别是什么">#</a> 6、bindtap 和 catchtap 的区别是什么？</h2><ul><li><strong>相同点</strong>：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分</li><li><strong>不同点</strong>：他们的不同点主要是 bindtap 是不会阻止冒泡事件的，catchtap 是阻止冒泡的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/08/18/hello-world/"/>
      <url>/2023/08/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>这是我的第一篇博客，开启我的代码编写之旅</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
